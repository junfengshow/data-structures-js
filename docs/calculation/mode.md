---
title: 算法模式
order: 1
footer: false
---
算法模式
===

## 1.递归
> 即函数自身调用自身。如果是匿名函数可以用arguments.callee(严格模式不支持)。
> 进行函数递归的时候因为是函数自己调用自己，所以必须要设置好不递归的条件。
> ES6有尾调用优化(tail call optimization).递归会一直执行下去
  
### 1.1调用栈大小限制(js)
不同的浏览器限制不同，当递归超出了调用栈的限制会抛出错误也就是栈的溢出错误。(stack overflow error)
+ ES6有尾调用优化(tail call optimization).递归会一直执行下去。
+ 如果函数内最后一个操作是调用函数，会通过‘跳转指令’jump而不是'子程序调用'(subroutine call)来控制。
+ 也就是说在es6中递归会一直执行下去。故而停止递归的条件很重要。

### 1.2斐波那契数列
+ 1和2的斐波那契数是1
+ n (n>2)的斐波那契数是n-1的斐波那契数加上n-2的斐波那契数
```typescript
function fibonacci(num: number): number { 
  // 递归停止条件
  if (num === 1 || num === 2){ 
    return 1; 
  } 
  return fibonacci(num - 1) + fibonacci(num - 2); 
}
```
### 1.3快速排序

---

## 2.动态规划
> dynamic programming DP, 是一种将复杂问题分解成更小的子问题来解决的优化技术。
> 动态规划和分而治之(归并、快速排序)是不同的方法。
> 分而治之是把问题分解成相互独立的子问题，然后组合它们的答案。
> 动态规划是将问题分解成相互依赖的子问题。

### 2.1三个重要步骤
+ 1.定义子问题
+ 2.实现要反复执行来解决子问题的不分
+ 3.识别并求解出边界条件

### 2.2经典问题
+ **1.背包问题:**
给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个
问题的限制是，总容量必须小于等于“背包”的容量。
+ **2.最长公共子序列:**
(找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。
+ **3.矩阵链相乘:**
给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。
相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。
+ **4.硬币找零:**
给出面额为d1...dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。
+ **5.图的全源最短路径:**
对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。

---
## 3.贪心算法
> 贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的
> 解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。

## 4.函数式编程
> 即以函数式范式进行开发。

### 4.1注意点
+ 主要目标是描述数据，以及要对数据应用对转换。
+ 程序执行顺序的重要性很低，而在命令式编程中，步骤和顺序是非常重要的。
+ 函数和数据集合是函数式编程的核心。
+ 在函数式编程中，我们可以使用和滥用函数和递归，而在命令式编程中，则使用循环、赋值和函数。

### 4.2常用函数(js)
+ 数组方法：map、filter、reduce
+ 数学方法：min、max、floor、ceil、round

### 4.3常用库
+ [Underscore.js](http://underscorejs.org/)
+ [Bilby.js](http://bilby.brianmckenna.org/)
+ Lazy.js
+ Bacon.js
+ Fn.js
+ Functional.js
+ Ramda.js
+ Mori
